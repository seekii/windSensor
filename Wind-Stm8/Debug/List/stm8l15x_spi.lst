###############################################################################
#
# IAR C/C++ Compiler V2.10.2.149 for STM8                 07/Dec/2016  10:10:38
# Copyright 2010-2014 IAR Systems AB.
#
#    Source file  =  
#        F:\share\gitHub\windSensor\Wind-Stm8\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_spi.c
#    Command line =  
#        F:\share\gitHub\windSensor\Wind-Stm8\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_spi.c
#        -e -Ol --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call --debug --code_model small --data_model medium -o
#        F:\share\gitHub\windSensor\Wind-Stm8\Debug\Obj\ --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\stm8\LIB\dlstm8smn.h" -D STM8L15X_MD -lCN
#        F:\share\gitHub\windSensor\Wind-Stm8\Debug\List\ --diag_suppress
#        Pe177,Pe550 -I
#        F:\share\gitHub\windSensor\Wind-Stm8\Project\Discover\inc\ -I
#        F:\share\gitHub\windSensor\Wind-Stm8\Libraries\STM8L15x_StdPeriph_Driver\inc\
#        --vregs 16
#    List file    =  
#        F:\share\gitHub\windSensor\Wind-Stm8\Debug\List\stm8l15x_spi.lst
#    Object file  =  
#        F:\share\gitHub\windSensor\Wind-Stm8\Debug\Obj\stm8l15x_spi.o
#
###############################################################################

F:\share\gitHub\windSensor\Wind-Stm8\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.4.0
      6            * @date    09/24/2010
      7            * @brief   This file provides all the SPI firmware functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm8l15x_spi.h"
     23          
     24          /** @addtogroup STM8L15x_StdPeriph_Driver
     25            * @{
     26            */
     27          
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          /* Private functions ---------------------------------------------------------*/
     34          
     35          /** @addtogroup SPI_Public_Functions
     36            * @{
     37            */
     38          
     39          /**
     40            * @brief  Deinitializes the SPI peripheral registers to their default reset values.
     41            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
     42            * @param  None
     43            * @retval None
     44            */

   \                                 In section .near_func.text, align 1
     45          void SPI_DeInit(SPI_TypeDef* SPIx)
     46          {
     47            SPIx->CR1    = SPI_CR1_RESET_VALUE;
   \                     SPI_DeInit:
   \   000000 4F           CLR       A
   \   000001 F7           LD        (X), A
     48            SPIx->CR2    = SPI_CR2_RESET_VALUE;
   \   000002 9093         LDW       Y, X
   \   000004 905C         INCW      Y
   \   000006 4F           CLR       A
   \   000007 90F7         LD        (Y), A
     49            SPIx->CR3    = SPI_CR3_RESET_VALUE;
   \   000009 9093         LDW       Y, X
   \   00000B 72A9 0002    ADDW      Y, #0x2
   \   00000F 4F           CLR       A
   \   000010 90F7         LD        (Y), A
     50            SPIx->SR     = SPI_SR_RESET_VALUE;
   \   000012 9093         LDW       Y, X
   \   000014 72A9 0003    ADDW      Y, #0x3
   \   000018 A6 02        LD        A, #0x2
   \   00001A 90F7         LD        (Y), A
     51            SPIx->CRCPR  = SPI_CRCPR_RESET_VALUE;
   \   00001C 1C 0005      ADDW      X, #0x5
   \   00001F A6 07        LD        A, #0x7
   \   000021 F7           LD        (X), A
     52          }
   \   000022 81           RET
     53          
     54          /**
     55            * @brief  Initializes the SPI according to the specified parameters.
     56            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
     57            * @param  SPI_FirstBit : This parameter can be any of the
     58            *         @ref SPI_FirstBit_TypeDef enumeration.
     59            * @param  SPI_BaudRatePrescaler : This parameter can be any of the
     60            *         @ref SPI_BaudRatePrescaler_TypeDef enumeration.
     61            * @param  SPI_Mode : This parameter can be any of the  @ref SPI_Mode_TypeDef
     62            *         enumeration.
     63            * @param  SPI_CPOL : This parameter can be any of the @ref SPI_CPOL_TypeDef
     64            *         enumeration.
     65            * @param  SPI_CPHA : This parameter can be any of the @ref SPI_CPHA_TypeDef
     66            *         enumeration.
     67            * @param  SPI_Data_Direction : This parameter can be any of the
     68            *         @ref SPI_DirectionMode_TypeDef enumeration.
     69            * @param  SPI_Slave_Management : This parameter can be any of the
     70            *         @ref SPI_NSS_TypeDef enumeration.
     71            * @param  CRCPolynomial : Configures the CRC polynomial.
     72            * @retval None
     73            */

   \                                 In section .near_func.text, align 1
     74          void SPI_Init(SPI_TypeDef* SPIx, SPI_FirstBit_TypeDef SPI_FirstBit,
     75                        SPI_BaudRatePrescaler_TypeDef SPI_BaudRatePrescaler,
     76                        SPI_Mode_TypeDef SPI_Mode, SPI_CPOL_TypeDef SPI_CPOL,
     77                        SPI_CPHA_TypeDef SPI_CPHA, SPI_DirectionMode_TypeDef SPI_Data_Direction,
     78                        SPI_NSS_TypeDef SPI_Slave_Management, uint8_t CRCPolynomial)
     79          {
   \                     SPI_Init:
   \   000000 B7 ..        LD        S:?b7, A
   \   000002 B6 ..        LD        A, S:?b3
     80            /* Check structure elements */
     81            assert_param(IS_SPI_FIRSTBIT(SPI_FirstBit));
     82            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_BaudRatePrescaler));
     83            assert_param(IS_SPI_MODE(SPI_Mode));
     84            assert_param(IS_SPI_POLARITY(SPI_CPOL));
     85            assert_param(IS_SPI_PHASE(SPI_CPHA));
     86            assert_param(IS_SPI_DATA_DIRECTION(SPI_Data_Direction));
     87            assert_param(IS_SPI_SLAVEMANAGEMENT(SPI_Slave_Management));
     88            assert_param(IS_SPI_CRC_POLYNOMIAL(CRCPolynomial));
     89          
     90            /* Frame Format, BaudRate, Clock Polarity and Phase configuration */
     91            SPIx->CR1 = (uint8_t)((uint8_t)((uint8_t)SPI_FirstBit |
     92                                            (uint8_t)SPI_BaudRatePrescaler) |
     93                                  (uint8_t)((uint8_t)SPI_CPOL |
     94                                            SPI_CPHA));
   \   000004 BA ..        OR        A, S:?b2
   \   000006 88           PUSH      A
   \   000007 B6 ..        LD        A, S:?b0
   \   000009 BA ..        OR        A, S:?b7
   \   00000B B7 ..        LD        S:?b0, A
   \   00000D 84           POP       A
   \   00000E BA ..        OR        A, S:?b0
   \   000010 F7           LD        (X), A
     95          
     96            /* Data direction configuration: BDM, BDOE and RXONLY bits */
     97            SPIx->CR2 = (uint8_t)((uint8_t)(SPI_Data_Direction) | (uint8_t)(SPI_Slave_Management));
   \   000011 B6 ..        LD        A, S:?b5
   \   000013 BA ..        OR        A, S:?b4
   \   000015 9093         LDW       Y, X
   \   000017 905C         INCW      Y
   \   000019 90F7         LD        (Y), A
     98          
     99            if (SPI_Mode == SPI_Mode_Master)
   \   00001B B6 ..        LD        A, S:?b1
   \   00001D A1 04        CP        A, #0x4
   \   00001F 26 10        JRNE      L:??SPI_Init_0
    100            {
    101              SPIx->CR2 |= (uint8_t)SPI_CR2_SSI;
   \   000021 9093         LDW       Y, X
   \   000023 905C         INCW      Y
   \   000025 90F6         LD        A, (Y)
   \   000027 AA 01        OR        A, #0x1
   \   000029 9093         LDW       Y, X
   \   00002B 905C         INCW      Y
   \   00002D 90F7         LD        (Y), A
   \   00002F 20 0E        JRA       L:??SPI_Init_1
    102            }
    103            else
    104            {
    105              SPIx->CR2 &= (uint8_t)~(SPI_CR2_SSI);
   \                     ??SPI_Init_0:
   \   000031 9093         LDW       Y, X
   \   000033 905C         INCW      Y
   \   000035 90F6         LD        A, (Y)
   \   000037 A4 FE        AND       A, #0xfe
   \   000039 9093         LDW       Y, X
   \   00003B 905C         INCW      Y
   \   00003D 90F7         LD        (Y), A
    106            }
    107          
    108            /* Master/Slave mode configuration */
    109            SPIx->CR1 |= (uint8_t)(SPI_Mode);
   \                     ??SPI_Init_1:
   \   00003F B6 ..        LD        A, S:?b1
   \   000041 FA           OR        A, (X)
   \   000042 F7           LD        (X), A
    110          
    111            /* CRC configuration */
    112            SPIx->CRCPR = (uint8_t)CRCPolynomial;
   \   000043 1C 0005      ADDW      X, #0x5
   \   000046 B6 ..        LD        A, S:?b6
   \   000048 F7           LD        (X), A
    113          }
   \   000049 81           RET
    114          
    115          /**
    116            * @brief  Enables or disables the SPI peripheral.
    117            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    118            * @param  NewState New state of the SPI peripheral.
    119            *         This parameter can be: ENABLE or DISABLE
    120            * @retval None
    121            */

   \                                 In section .near_func.text, align 1
    122          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    123          {
    124            /* Check function parameters */
    125            assert_param(IS_FUNCTIONAL_STATE(NewState));
    126          
    127            if (NewState != DISABLE)
   \                     SPI_Cmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??SPI_Cmd_0
    128            {
    129              SPIx->CR1 |= SPI_CR1_SPE; /* Enable the SPI peripheral*/
   \   000003 F6           LD        A, (X)
   \   000004 AA 40        OR        A, #0x40
   \   000006 F7           LD        (X), A
   \   000007 81           RET
    130            }
    131            else
    132            {
    133              SPIx->CR1 &= (uint8_t)(~SPI_CR1_SPE); /* Disable the SPI peripheral*/
   \                     ??SPI_Cmd_0:
   \   000008 F6           LD        A, (X)
   \   000009 A4 BF        AND       A, #0xbf
   \   00000B F7           LD        (X), A
    134            }
    135          }
   \   00000C 81           RET
    136          
    137          /**
    138            * @brief  Enables or disables the specified interrupts.
    139            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    140            * @param  SPI_IT Specifies the SPI interrupts sources to be enabled or disabled.
    141            * @param  NewState: The new state of the specified SPI interrupts.
    142            *         This parameter can be: ENABLE or DISABLE.
    143            * @retval None
    144            */

   \                                 In section .near_func.text, align 1
    145          void SPI_ITConfig(SPI_TypeDef* SPIx, SPI_IT_TypeDef SPI_IT, FunctionalState NewState)
    146          {
   \                     SPI_ITConfig:
   \   000000 9093         LDW       Y, X
    147            uint8_t itpos = 0;
   \   000002 3F ..        CLR       S:?b1
    148            /* Check function parameters */
    149            assert_param(IS_SPI_CONFIG_IT(SPI_IT));
    150            assert_param(IS_FUNCTIONAL_STATE(NewState));
    151          
    152            /* Get the SPI IT index */
    153            itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)SPI_IT & (uint8_t)0x0F));
   \   000004 A4 0F        AND       A, #0xf
   \   000006 5F           CLRW      X
   \   000007 5C           INCW      X
   \   000008 CD ....      CALL      L:?sll16_x_x_a
   \   00000B 9F           LD        A, XL
   \   00000C B7 ..        LD        S:?b1, A
    154          
    155            if (NewState != DISABLE)
   \   00000E 3D ..        TNZ       S:?b0
   \   000010 27 0E        JREQ      L:??SPI_ITConfig_0
    156            {
    157              SPIx->CR3 |= itpos; /* Enable interrupt*/
   \   000012 93           LDW       X, Y
   \   000013 1C 0002      ADDW      X, #0x2
   \   000016 B6 ..        LD        A, S:?b1
   \   000018 FA           OR        A, (X)
   \   000019 72A9 0002    ADDW      Y, #0x2
   \   00001D 90F7         LD        (Y), A
   \   00001F 81           RET
    158            }
    159            else
    160            {
    161              SPIx->CR3 &= (uint8_t)(~itpos); /* Disable interrupt*/
   \                     ??SPI_ITConfig_0:
   \   000020 93           LDW       X, Y
   \   000021 1C 0002      ADDW      X, #0x2
   \   000024 33 ..        CPL       S:?b1
   \   000026 B6 ..        LD        A, S:?b1
   \   000028 F4           AND       A, (X)
   \   000029 72A9 0002    ADDW      Y, #0x2
   \   00002D 90F7         LD        (Y), A
    162            }
    163          }
   \   00002F 81           RET
    164          /**
    165            * @brief  Transmits a Data through the SPI peripheral.
    166            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    167            * @param  Data : Byte to be transmitted.
    168            * @retval None
    169            */

   \                                 In section .near_func.text, align 1
    170          void SPI_SendData(SPI_TypeDef* SPIx, uint8_t Data)
    171          {
    172            SPIx->DR = Data; /* Write in the DR register the data to be sent*/
   \                     SPI_SendData:
   \   000000 1C 0004      ADDW      X, #0x4
   \   000003 F7           LD        (X), A
    173          }
   \   000004 81           RET
    174          
    175          /**
    176            * @brief  Returns the most recent received data by the SPI peripheral.
    177            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    178            * @retval The value of the received data.
    179            */

   \                                 In section .near_func.text, align 1
    180          uint8_t SPI_ReceiveData(SPI_TypeDef* SPIx)
    181          {
    182            return ((uint8_t)SPIx->DR); /* Return the data in the DR register*/
   \                     SPI_ReceiveData:
   \   000000 1C 0004      ADDW      X, #0x4
   \   000003 F6           LD        A, (X)
   \   000004 81           RET
    183          }
    184          
    185          /**
    186            * @brief  Configures internally by software the NSS pin.
    187            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    188            * @param  NewState Indicates the new state of the SPI Software slave management.
    189            *         This parameter can be: ENABLE or DISABLE.
    190            * @retval None
    191            */

   \                                 In section .near_func.text, align 1
    192          void SPI_NSSInternalSoftwareCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    193          {
    194            /* Check function parameters */
    195            assert_param(IS_FUNCTIONAL_STATE(NewState));
    196          
    197            if (NewState != DISABLE)
   \                     SPI_NSSInternalSoftwareCmd:
   \   000000 4D           TNZ       A
   \   000001 27 0B        JREQ      L:??SPI_NSSInternalSoftwareCmd_0
    198            {
    199              SPIx->CR2 |= SPI_CR2_SSI; /* Set NSS pin internally by software*/
   \   000003 9093         LDW       Y, X
   \   000005 905C         INCW      Y
   \   000007 90F6         LD        A, (Y)
   \   000009 AA 01        OR        A, #0x1
   \   00000B 5C           INCW      X
   \   00000C F7           LD        (X), A
   \   00000D 81           RET
    200            }
    201            else
    202            {
    203              SPIx->CR2 &= (uint8_t)(~SPI_CR2_SSI); /* Reset NSS pin internally by software*/
   \                     ??SPI_NSSInternalSoftwareCmd_0:
   \   00000E 9093         LDW       Y, X
   \   000010 905C         INCW      Y
   \   000012 90F6         LD        A, (Y)
   \   000014 A4 FE        AND       A, #0xfe
   \   000016 5C           INCW      X
   \   000017 F7           LD        (X), A
    204            }
    205          }
   \   000018 81           RET
    206          
    207          /**
    208            * @brief  Enables the transmit of the CRC value.
    209            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    210            * @retval None
    211            */

   \                                 In section .near_func.text, align 1
    212          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    213          {
    214            SPIx->CR2 |= SPI_CR2_CRCNEXT; /* Enable the CRC transmission*/
   \                     SPI_TransmitCRC:
   \   000000 9093         LDW       Y, X
   \   000002 905C         INCW      Y
   \   000004 90F6         LD        A, (Y)
   \   000006 AA 10        OR        A, #0x10
   \   000008 5C           INCW      X
   \   000009 F7           LD        (X), A
    215          }
   \   00000A 81           RET
    216          
    217          /**
    218            * @brief  Enables or disables the CRC value calculation of the transfered bytes.
    219            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    220            * @param  NewState Indicates the new state of the SPI CRC value calculation.
    221            *         This parameter can be: ENABLE or DISABLE.
    222            * @retval None
    223            */

   \                                 In section .near_func.text, align 1
    224          void SPI_CalculateCRCCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    225          {
   \                     SPI_CalculateCRCCmd:
   \   000000 CD ....      CALL      L:?push_w4
   \   000003 3B ....      PUSH      S:?b10
   \   000006 BF ..        LDW       S:?w4, X
   \   000008 B7 ..        LD        S:?b10, A
    226            /* Check function parameters */
    227            assert_param(IS_FUNCTIONAL_STATE(NewState));
    228          
    229            /* SPI must be disable forcorrect operation od Hardware CRC calculation */
    230            SPI_Cmd(SPI1, DISABLE);
   \   00000A 4F           CLR       A
   \   00000B AE 5200      LDW       X, #0x5200
   \   00000E CD ....      CALL      L:SPI_Cmd
    231          
    232            if (NewState != DISABLE)
   \   000011 3D ..        TNZ       S:?b10
   \   000013 27 0C        JREQ      L:??SPI_CalculateCRCCmd_0
    233            {
    234              SPIx->CR2 |= SPI_CR2_CRCEN; /* Enable the CRC calculation*/
   \   000015 BE ..        LDW       X, S:?w4
   \   000017 5C           INCW      X
   \   000018 F6           LD        A, (X)
   \   000019 AA 20        OR        A, #0x20
   \   00001B BE ..        LDW       X, S:?w4
   \   00001D 5C           INCW      X
   \   00001E F7           LD        (X), A
   \   00001F 20 0A        JRA       L:??SPI_CalculateCRCCmd_1
    235            }
    236            else
    237            {
    238              SPIx->CR2 &= (uint8_t)(~SPI_CR2_CRCEN); /* Disable the CRC calculation*/
   \                     ??SPI_CalculateCRCCmd_0:
   \   000021 BE ..        LDW       X, S:?w4
   \   000023 5C           INCW      X
   \   000024 F6           LD        A, (X)
   \   000025 A4 DF        AND       A, #0xdf
   \   000027 BE ..        LDW       X, S:?w4
   \   000029 5C           INCW      X
   \   00002A F7           LD        (X), A
    239            }
    240          }
   \                     ??SPI_CalculateCRCCmd_1:
   \   00002B 32 ....      POP       S:?b10
   \   00002E CC ....      JP        L:?epilogue_w4
    241          
    242          /**
    243            * @brief  Returns the transmit or the receive CRC register value.
    244            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    245            * @param  SPI_CRC Specifies the CRC register to be read.
    246            * @retval The selected CRC register value.
    247            */

   \                                 In section .near_func.text, align 1
    248          uint8_t SPI_GetCRC(SPI_TypeDef* SPIx, SPI_CRC_TypeDef SPI_CRC)
    249          {
    250            uint8_t crcreg = 0;
   \                     SPI_GetCRC:
   \   000000 3F ..        CLR       S:?b0
    251          
    252            /* Check function parameters */
    253            assert_param(IS_SPI_CRC(SPI_CRC));
    254          
    255            if (SPI_CRC != SPI_CRC_RX)
   \   000002 4D           TNZ       A
   \   000003 27 08        JREQ      L:??SPI_GetCRC_0
    256            {
    257              crcreg = SPIx->TXCRCR;  /* Get the Tx CRC register*/
   \   000005 1C 0007      ADDW      X, #0x7
   \   000008 F6           LD        A, (X)
   \   000009 B7 ..        LD        S:?b0, A
   \   00000B 20 06        JRA       L:??SPI_GetCRC_1
    258            }
    259            else
    260            {
    261              crcreg = SPIx->RXCRCR; /* Get the Rx CRC register*/
   \                     ??SPI_GetCRC_0:
   \   00000D 1C 0006      ADDW      X, #0x6
   \   000010 F6           LD        A, (X)
   \   000011 B7 ..        LD        S:?b0, A
    262            }
    263          
    264            /* Return the selected CRC register status*/
    265            return crcreg;
   \                     ??SPI_GetCRC_1:
   \   000013 B6 ..        LD        A, S:?b0
   \   000015 81           RET
    266          }
    267          
    268          /**
    269            * @brief  Reset the Rx CRCR and Tx CRCR registers.
    270            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    271            * @retval None
    272            */

   \                                 In section .near_func.text, align 1
    273          void SPI_ResetCRC(SPI_TypeDef* SPIx)
    274          {
   \                     SPI_ResetCRC:
   \   000000 CD ....      CALL      L:?push_w4
   \   000003 BF ..        LDW       S:?w4, X
    275            /* Rx CRCR & Tx CRCR registers are reset when CRCEN (hardware calculation)
    276               bit in SPI_CR2 is written to 1 (enable) */
    277            SPI_CalculateCRCCmd(SPIx, ENABLE);
   \   000005 A6 01        LD        A, #0x1
   \   000007 BE ..        LDW       X, S:?w4
   \   000009 CD ....      CALL      L:SPI_CalculateCRCCmd
    278          
    279            /* Previous function disable the SPI */
    280            SPI_Cmd(SPIx, ENABLE);
   \   00000C A6 01        LD        A, #0x1
   \   00000E BE ..        LDW       X, S:?w4
   \   000010 CD ....      CALL      L:SPI_Cmd
    281          }
   \   000013 CC ....      JP        L:?epilogue_w4
    282          
    283          /**
    284            * @brief  Returns the CRC Polynomial register value.
    285            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    286            * @retval uint8_t The CRC Polynomial register value.
    287            */

   \                                 In section .near_func.text, align 1
    288          uint8_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    289          {
    290            return SPIx->CRCPR; /* Return the CRC polynomial register */
   \                     SPI_GetCRCPolynomial:
   \   000000 1C 0005      ADDW      X, #0x5
   \   000003 F6           LD        A, (X)
   \   000004 81           RET
    291          }
    292          
    293          /**
    294            * @brief  Selects the data transfer direction in bi-directional mode.
    295            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    296            * @param  SPI_Direction Specifies the data transfer direction in bi-directional mode.
    297            * @retval None
    298            */

   \                                 In section .near_func.text, align 1
    299          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, SPI_Direction_TypeDef SPI_Direction)
    300          {
    301            /* Check function parameters */
    302            assert_param(IS_SPI_DIRECTION(SPI_Direction));
    303          
    304            if (SPI_Direction != SPI_Direction_Rx)
   \                     SPI_BiDirectionalLineConfig:
   \   000000 4D           TNZ       A
   \   000001 27 0B        JREQ      L:??SPI_BiDirectionalLineConfig_0
    305            {
    306              SPIx->CR2 |= SPI_CR2_BDOE; /* Set the Tx only mode*/
   \   000003 9093         LDW       Y, X
   \   000005 905C         INCW      Y
   \   000007 90F6         LD        A, (Y)
   \   000009 AA 40        OR        A, #0x40
   \   00000B 5C           INCW      X
   \   00000C F7           LD        (X), A
   \   00000D 81           RET
    307            }
    308            else
    309            {
    310              SPIx->CR2 &= (uint8_t)(~SPI_CR2_BDOE); /* Set the Rx only mode*/
   \                     ??SPI_BiDirectionalLineConfig_0:
   \   00000E 9093         LDW       Y, X
   \   000010 905C         INCW      Y
   \   000012 90F6         LD        A, (Y)
   \   000014 A4 BF        AND       A, #0xbf
   \   000016 5C           INCW      X
   \   000017 F7           LD        (X), A
    311            }
    312          }
   \   000018 81           RET
    313          /**
    314            * @brief  Enables or disables the SPI DMA interface.
    315            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    316            * @param  SPI_DMAReq Specifies the SPI DMA transfer request to be enabled or disabled.
    317            *         This parameter can be any of the @ref SPI_DMAReq_TypeDef enumeration.
    318            * @param  NewState Indicates the new state of the SPI DMA request.
    319            *         This parameter can be any of the @ref FunctionalState enumeration.
    320            * @retval None
    321            */

   \                                 In section .near_func.text, align 1
    322          void SPI_DMACmd(SPI_TypeDef* SPIx, SPI_DMAReq_TypeDef SPI_DMAReq, FunctionalState NewState)
    323          {
    324            /* Check the parameters */
    325            assert_param(IS_FUNCTIONAL_STATE(NewState));
    326            assert_param(IS_SPI_DMAREQ(SPI_DMAReq));
    327          
    328            if (NewState != DISABLE)
   \                     SPI_DMACmd:
   \   000000 3D ..        TNZ       S:?b0
   \   000002 27 0D        JREQ      L:??SPI_DMACmd_0
    329            {
    330              /* Enable the selected SPI DMA requests */
    331              SPIx->CR3 |= (uint8_t) SPI_DMAReq;
   \   000004 9093         LDW       Y, X
   \   000006 72A9 0002    ADDW      Y, #0x2
   \   00000A 90FA         OR        A, (Y)
   \   00000C 1C 0002      ADDW      X, #0x2
   \   00000F F7           LD        (X), A
   \   000010 81           RET
    332            }
    333            else
    334            {
    335              /* Disable the selected SPI DMA requests */
    336              SPIx->CR3 &= (uint8_t)~SPI_DMAReq;
   \                     ??SPI_DMACmd_0:
   \   000011 9093         LDW       Y, X
   \   000013 72A9 0002    ADDW      Y, #0x2
   \   000017 43           CPL       A
   \   000018 90F4         AND       A, (Y)
   \   00001A 1C 0002      ADDW      X, #0x2
   \   00001D F7           LD        (X), A
    337            }
    338          }
   \   00001E 81           RET
    339          /**
    340            * @brief  Checks whether the specified SPI flag is set or not.
    341            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    342            * @param  SPI_FLAG : Specifies the flag to check.
    343            *         This parameter can be any of the @ref SPI_FLAG_TypeDef enumeration.
    344            * @retval FlagStatus : Indicates the state of SPI_FLAG.
    345            *         This parameter can be any of the @ref FlagStatus enumeration.
    346            */
    347          

   \                                 In section .near_func.text, align 1
    348          FlagStatus SPI_GetFlagStatus(SPI_TypeDef* SPIx, SPI_FLAG_TypeDef SPI_FLAG)
    349          {
    350            FlagStatus status = RESET;
   \                     SPI_GetFlagStatus:
   \   000000 3F ..        CLR       S:?b0
    351            /* Check parameters */
    352            assert_param(IS_SPI_FLAG(SPI_FLAG));
    353          
    354            /* Check the status of the specified SPI flag */
    355            if ((SPIx->SR & (uint8_t)SPI_FLAG) != (uint8_t)RESET)
   \   000002 1C 0003      ADDW      X, #0x3
   \   000005 F4           AND       A, (X)
   \   000006 A1 00        CP        A, #0x0
   \   000008 27 06        JREQ      L:??SPI_GetFlagStatus_0
    356            {
    357              status = SET; /* SPI_FLAG is set */
   \   00000A 35 01 ....   MOV       S:?b0, #0x1
   \   00000E 20 02        JRA       L:??SPI_GetFlagStatus_1
    358            }
    359            else
    360            {
    361              status = RESET; /* SPI_FLAG is reset*/
   \                     ??SPI_GetFlagStatus_0:
   \   000010 3F ..        CLR       S:?b0
    362            }
    363          
    364            /* Return the SPI_FLAG status */
    365            return status;
   \                     ??SPI_GetFlagStatus_1:
   \   000012 B6 ..        LD        A, S:?b0
   \   000014 81           RET
    366          }
    367          
    368          /**
    369            * @brief  Clears the SPI flags.
    370            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    371            * @param  SPI_FLAG : Specifies the flag to clear.
    372            *         This parameter can be one of the following values:
    373            *         - SPI_FLAG_CRCERR
    374            *         - SPI_FLAG_WKUP
    375            * @note   - OVR (OverRun Error) interrupt pending bit is cleared by software
    376            *         sequence:
    377            *         a read operation to SPI_DR register (SPI_ReceiveData()) followed by
    378            *         a read operation to SPI_SR register (SPI_GetFlagStatus()).
    379            *         - MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
    380            *         a read/write operation to SPI_SR register (SPI_GetFlagStatus()) followed by
    381            *         a write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
    382            * @retval None
    383            */

   \                                 In section .near_func.text, align 1
    384          void SPI_ClearFlag(SPI_TypeDef* SPIx, SPI_FLAG_TypeDef SPI_FLAG)
    385          {
    386            assert_param(IS_SPI_CLEAR_FLAG(SPI_FLAG));
    387            /* Clear the flag bit */
    388            SPIx->SR = (uint8_t)(~SPI_FLAG);
   \                     SPI_ClearFlag:
   \   000000 1C 0003      ADDW      X, #0x3
   \   000003 43           CPL       A
   \   000004 F7           LD        (X), A
    389          }
   \   000005 81           RET
    390          
    391          /**
    392            * @brief  Checks whether the specified interrupt has occurred or not.
    393            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    394            * @param  SPI_IT: Specifies the SPI interrupt pending bit to check.
    395            *         This parameter can be one of the following values:
    396            *         - SPI_IT_CRCERR
    397            *         - SPI_IT_WKUP
    398            *         - SPI_IT_OVR
    399            *         - SPI_IT_MODF
    400            *         - SPI_IT_RXNE
    401            *         - SPI_IT_TXE
    402            * @retval ITStatus : Indicates the state of the SPI_IT.
    403            *         This parameter can be any of the @ref ITStatus enumeration.
    404            */

   \                                 In section .near_func.text, align 1
    405          ITStatus SPI_GetITStatus(SPI_TypeDef* SPIx, SPI_IT_TypeDef SPI_IT)
    406          {
   \                     SPI_GetITStatus:
   \   000000 52 01        SUB       SP, #0x1
   \   000002 9093         LDW       Y, X
   \   000004 B7 ..        LD        S:?b4, A
    407            ITStatus pendingbitstatus = RESET;
   \   000006 3F ..        CLR       S:?b0
    408            uint8_t itpos = 0;
   \   000008 3F ..        CLR       S:?b3
    409            uint8_t itmask1 = 0;
   \   00000A 3F ..        CLR       S:?b1
    410            uint8_t itmask2 = 0;
   \   00000C 3F ..        CLR       S:?b2
    411            __IO uint8_t enablestatus = 0;
   \   00000E 4F           CLR       A
   \   00000F 6B 01        LD        (0x1,SP), A
    412            assert_param(IS_SPI_GET_IT(SPI_IT));
    413            /* Get the SPI IT index */
    414            itpos = (uint8_t)((uint8_t)1 << ((uint8_t)SPI_IT & (uint8_t)0x0F));
   \   000011 B6 ..        LD        A, S:?b4
   \   000013 A4 0F        AND       A, #0xf
   \   000015 5F           CLRW      X
   \   000016 5C           INCW      X
   \   000017 CD ....      CALL      L:?sll16_x_x_a
   \   00001A 9F           LD        A, XL
   \   00001B B7 ..        LD        S:?b3, A
    415          
    416            /* Get the SPI IT mask */
    417            itmask1 = (uint8_t)((uint8_t)SPI_IT >> (uint8_t)4);
   \   00001D B6 ..        LD        A, S:?b4
   \   00001F 4E           SWAP      A
   \   000020 A4 0F        AND       A, #0xf
   \   000022 B7 ..        LD        S:?b1, A
    418            /* Set the IT mask */
    419            itmask2 = (uint8_t)((uint8_t)1 << itmask1);
   \   000024 5F           CLRW      X
   \   000025 5C           INCW      X
   \   000026 B6 ..        LD        A, S:?b1
   \   000028 CD ....      CALL      L:?sll16_x_x_a
   \   00002B 9F           LD        A, XL
   \   00002C B7 ..        LD        S:?b2, A
    420            /* Get the SPI_IT enable bit status */
    421            enablestatus = (uint8_t)((uint8_t)SPIx->SR & itmask2);
   \   00002E 93           LDW       X, Y
   \   00002F 1C 0003      ADDW      X, #0x3
   \   000032 B6 ..        LD        A, S:?b2
   \   000034 F4           AND       A, (X)
   \   000035 6B 01        LD        (0x1,SP), A
    422            /* Check the status of the specified SPI interrupt */
    423            if (((SPIx->CR3 & itpos) != RESET) && enablestatus)
   \   000037 72A9 0002    ADDW      Y, #0x2
   \   00003B B6 ..        LD        A, S:?b3
   \   00003D 90F4         AND       A, (Y)
   \   00003F A1 00        CP        A, #0x0
   \   000041 27 0A        JREQ      L:??SPI_GetITStatus_0
   \   000043 0D 01        TNZ       (0x1,SP)
   \   000045 27 06        JREQ      L:??SPI_GetITStatus_0
    424            {
    425              /* SPI_IT is set */
    426              pendingbitstatus = SET;
   \   000047 35 01 ....   MOV       S:?b0, #0x1
   \   00004B 20 02        JRA       L:??SPI_GetITStatus_1
    427            }
    428            else
    429            {
    430              /* SPI_IT is reset */
    431              pendingbitstatus = RESET;
   \                     ??SPI_GetITStatus_0:
   \   00004D 3F ..        CLR       S:?b0
    432            }
    433            /* Return the SPI_IT status */
    434            return  pendingbitstatus;
   \                     ??SPI_GetITStatus_1:
   \   00004F B6 ..        LD        A, S:?b0
   \   000051 5B 01        ADD       SP, #0x1
   \   000053 81           RET
    435          }
    436          
    437          /**
    438            * @brief  Clears the interrupt pending bits.
    439            * @param  SPIx : where x can be 1 to select the specified SPI peripheral.
    440            * @param  SPI_IT: Specifies the interrupt pending bit to clear.
    441            *         This parameter can be one of the following values:
    442            *         - SPI_IT_CRCERR
    443            *         - SPI_IT_WKUP
    444            * @note   - OVR (OverRun Error) interrupt pending bit is cleared by software sequence:
    445            *         a read operation to SPI_DR register (SPI_ReceiveData()) followed by
    446            *         a read operation to SPI_SR register (SPI_GetITStatus()).
    447            *         - MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
    448            *         a read/write operation to SPI_SR register (SPI_GetITStatus()) followed by
    449            *         a write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
    450            * @retval None
    451            */

   \                                 In section .near_func.text, align 1
    452          void SPI_ClearITPendingBit(SPI_TypeDef* SPIx, SPI_IT_TypeDef SPI_IT)
    453          {
   \                     SPI_ClearITPendingBit:
   \   000000 9093         LDW       Y, X
    454            uint8_t itpos = 0;
   \   000002 3F ..        CLR       S:?b0
    455            assert_param(IS_SPI_CLEAR_IT(SPI_IT));
    456          
    457            /* Clear  SPI_IT_CRCERR or SPI_IT_WKUP interrupt pending bits */
    458          
    459            /* Get the SPI pending bit index */
    460            itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)(SPI_IT & (uint8_t)0xF0) >> 4));
   \   000004 4E           SWAP      A
   \   000005 A4 0F        AND       A, #0xf
   \   000007 5F           CLRW      X
   \   000008 5C           INCW      X
   \   000009 CD ....      CALL      L:?sll16_x_x_a
   \   00000C 9F           LD        A, XL
   \   00000D B7 ..        LD        S:?b0, A
    461            /* Clear the pending bit */
    462            SPIx->SR = (uint8_t)(~itpos);
   \   00000F 72A9 0003    ADDW      Y, #0x3
   \   000013 33 ..        CPL       S:?b0
   \   000015 B6 ..        LD        A, S:?b0
   \   000017 90F7         LD        (Y), A
    463          
    464          }
   \   000019 81           RET
    465          /**
    466            * @}
    467            */
    468          
    469          /**
    470            * @}
    471            */
    472          
    473          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      25  SPI_BiDirectionalLineConfig
      49  SPI_CalculateCRCCmd
       6  SPI_ClearFlag
      26  SPI_ClearITPendingBit
      13  SPI_Cmd
      31  SPI_DMACmd
      35  SPI_DeInit
      22  SPI_GetCRC
       5  SPI_GetCRCPolynomial
      21  SPI_GetFlagStatus
      84  SPI_GetITStatus
      48  SPI_ITConfig
      74  SPI_Init
      25  SPI_NSSInternalSoftwareCmd
       5  SPI_ReceiveData
      22  SPI_ResetCRC
       5  SPI_SendData
      11  SPI_TransmitCRC

 
 507 bytes in section .near_func.text
 
 507 bytes of CODE memory

Errors: none
Warnings: none
